const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const cors = require('cors');
const bodyParser = require('body-parser');
const fs = require('fs');
const path = require('path');

const app = express();
app.use(cors());
app.use(bodyParser.json());

const server = http.createServer(app);
const io = new Server(server, {
    cors: { origin: '*', methods: ['GET', 'POST'] }
});

// For tracking disconnect grace periods
const disconnectTimers = new Map();

// â”€â”€â”€ Constants â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const GAME_DURATION_MS = 3 * 60 * 1000; // 3 minutes
const TICK_INTERVAL_MS = 100;           // 10 ticks/sec

// â”€â”€â”€ State â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// gameId â†’ { roomId, gameId, tickInterval, timer, startTime, delegated: Set<socketId>, player1: Socket, player2: Socket }
const activeGames = new Map();

// clanKey â†’ [{ sender, role, message, time, isSystem }]
const clanChats = new Map();

// â”€â”€â”€ Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function getGameRoom(socket) {
    for (const room of socket.rooms) {
        if (room !== socket.id) return room;
    }
    return null;
}

function cleanupGame(gameId) {
    const game = activeGames.get(gameId);
    if (!game) return;
    clearInterval(game.tickInterval);
    clearTimeout(game.timer);
    activeGames.delete(gameId);
    console.log(`ðŸ§¹ Cleaned up game ${gameId}`);
}

function startBattleClock(gameId, roomId) {
    const game = activeGames.get(gameId);
    if (!game || game.tickInterval) return; // already started

    const startTime = Date.now();
    game.startTime = startTime;
    console.log(`âš”ï¸  Battle clock started â€” room ${roomId}`);

    const tickInterval = setInterval(() => {
        const elapsed = Date.now() - startTime;
        const remaining = Math.max(0, GAME_DURATION_MS - elapsed);
        io.to(roomId).emit('tick', { elapsed, remaining });
        if (remaining <= 0) clearInterval(tickInterval);
    }, TICK_INTERVAL_MS);

    const timer = setTimeout(() => {
        console.log(`â° Game ${gameId} timed out`);
        io.to(roomId).emit('game-timeout', { gameId });
        cleanupGame(gameId);
    }, GAME_DURATION_MS);

    game.tickInterval = tickInterval;
    game.timer = timer;

    io.to(roomId).emit('battle-started', { gameId, startTime });
}

// â”€â”€â”€ Socket.IO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
io.on('connection', (socket) => {
    const walletPublicKey = socket.handshake.query.walletPublicKey;
    if (!walletPublicKey) { socket.disconnect(); return; }

    socket.walletPublicKey = walletPublicKey;
    socket.delegated = false;
    console.log(`âœ… Connected: ${socket.id} | Wallet: ${walletPublicKey}`);
    socket.emit('connect_ack', { id: socket.id, wallet: walletPublicKey });

    // â”€â”€ Manual Game Creation & Joining â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    // Player 1 creates a new room (ID generated by client)
    socket.on('create-room', (data) => {
        const { gameId } = data || {};
        if (!gameId) return;

        // If for some astronomically rare reason a collision occurs locally, just overwrite or reject
        // We'll trust the client ID here since we assume it's valid if it passed on-chain
        const roomId = `room_${gameId}`;

        socket.join(roomId);
        socket.gameId = gameId;
        socket.roomId = roomId;
        socket.role = 'player1';

        // Register game in pending state (waiting for player2)
        activeGames.set(gameId, {
            roomId, gameId,
            tickInterval: null, timer: null, startTime: null,
            delegated: new Set(),
            player1: socket,
            player2: null
        });

        console.log(`ðŸ  Room created: ${gameId} by ${socket.walletPublicKey}`);
    });

    // Player 2 joins an existing room
    socket.on('join-room', (data) => {
        const { gameId } = data;
        const game = activeGames.get(gameId);

        if (!game) {
            socket.emit('error', { message: 'Game not found / Invalid Code' });
            return;
        }

        if (game.player2) {
            socket.emit('error', { message: 'Game is already full' });
            return;
        }

        const roomId = game.roomId;
        socket.join(roomId);
        socket.gameId = gameId;
        socket.roomId = roomId;
        socket.role = 'player2';

        game.player2 = socket;

        console.log(`ðŸŽ® Match: ${game.player1.walletPublicKey} vs ${socket.walletPublicKey} | game=${gameId}`);

        // Emit game-start to both players so they can do on-chain init & navigate
        io.to(game.player1.id).emit('game-start', {
            gameId, role: 'player1', opponentWallet: socket.walletPublicKey, roomId
        });
        io.to(socket.id).emit('game-start', {
            gameId, role: 'player2', opponentWallet: game.player1.walletPublicKey, roomId
        });
    });

    // â”€â”€ Rejoin after navigation (GameWrapper opens a fresh socket) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Client emits { gameId, role } so we can re-associate into the room.
    socket.on('rejoin-game', (data) => {
        const { gameId, role } = data;
        const game = activeGames.get(gameId);
        if (!game) {
            socket.emit('error', { message: `Game ${gameId} not found` });
            return;
        }

        const roomId = game.roomId;
        socket.join(roomId);
        socket.gameId = gameId;
        socket.roomId = roomId;
        socket.role = role;
        socket.delegated = false;

        console.log(`ðŸ”„ Rejoin: ${socket.id} role=${role} game=${gameId}`);

        // If battle already started, send current tick so client can sync
        if (game.startTime) {
            const elapsed = Date.now() - game.startTime;
            const remaining = Math.max(0, GAME_DURATION_MS - elapsed);
            socket.emit('tick', { elapsed, remaining });
            socket.emit('battle-started', { gameId, startTime: game.startTime });
        }

        // Clear any disconnect timers for this role
        const graceTimerKey = `${gameId}-${role}`;
        if (disconnectTimers.has(graceTimerKey)) {
            clearTimeout(disconnectTimers.get(graceTimerKey));
            disconnectTimers.delete(graceTimerKey);
            console.log(`â±ï¸ Cleared disconnect grace period for ${graceTimerKey}`);
            socket.to(socket.roomId).emit('opponent-reconnected', { role: socket.role });
        }
    });

    // â”€â”€ Only Player 1 delegates the battle PDA to the ER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Player 2 never calls delegateGame (one-time, one-payer operation).
    // As soon as player1 signals 'delegated', start the clock for both.
    socket.on('delegated', () => {
        console.log(`ðŸ›¡ï¸  Delegated: ${socket.id} role=${socket.role}`);

        const roomId = socket.roomId;
        const gameId = socket.gameId;
        if (!roomId || !gameId || socket.role !== 'player1') {
            // Ignore signals from player2 (they shouldn't be calling this)
            if (socket.role !== 'player1') {
                console.warn(`âš ï¸  Unexpected delegated signal from role=${socket.role} â€” ignored`);
            }
            return;
        }

        const game = activeGames.get(gameId);
        if (!game || game.tickInterval) return; // already started

        startBattleClock(gameId, roomId);
    });

    // â”€â”€ Troop relay â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Shape: { cardIdx, cardId, x, y }
    socket.on('deploy-troop', (data) => {
        const roomId = getGameRoom(socket);
        if (!roomId) return;
        console.log(`ðŸª– ${socket.role} deployed cardIdx=${data.cardIdx} at (${data.x},${data.y})`);
        socket.to(roomId).emit('opponent-deploy-troop', {
            cardIdx: data.cardIdx,
            cardId: data.cardId,   // human-readable name e.g. 'Giant'
            x: data.x,
            y: data.y,
            ownerRole: socket.role,
        });
    });

    // â”€â”€ Continuous Sync (Host-based) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // Player 1 sends the snapshots of all entities periodically.
    socket.on('sync-units', (data) => {
        const roomId = getGameRoom(socket);
        if (!roomId) return;
        // Relay to other players
        socket.to(roomId).emit('sync-units', data);
    });

    // â”€â”€ Clan Chat â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    socket.on('join-clan', (data) => {
        const { clanKey } = data;
        if (!clanKey) return;

        const roomId = `clan_${clanKey}`;
        socket.join(roomId);
        console.log(`ðŸ° ${socket.walletPublicKey} joined clan room ${clanKey}`);

        // Send chat history if it exists
        const history = clanChats.get(clanKey) || [];
        socket.emit('clan-chat-history', history);
    });

    socket.on('leave-clan', (data) => {
        const { clanKey } = data;
        if (!clanKey) return;

        const roomId = `clan_${clanKey}`;
        socket.leave(roomId);
        console.log(`ðŸƒ ${socket.walletPublicKey} left clan room ${clanKey}`);
    });

    socket.on('clan-chat-message', (data) => {
        const { clanKey, message, sender, role } = data;
        if (!clanKey || !message) return;

        const roomId = `clan_${clanKey}`;

        const msgObj = {
            sender: sender || socket.walletPublicKey.slice(0, 6),
            role: role || 'Member',
            message,
            time: new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
            isSystem: false
        };

        // Save to history (keep last 50)
        if (!clanChats.has(clanKey)) clanChats.set(clanKey, []);
        const history = clanChats.get(clanKey);
        history.push(msgObj);
        if (history.length > 50) history.shift();

        // Broadcast to room
        io.to(roomId).emit('clan-chat-message', msgObj);
    });

    // â”€â”€ Disconnect â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    socket.on('disconnect', () => {
        console.log(`ðŸ‘‹ Disconnected: ${socket.id} (Role: ${socket.role}, Room: ${socket.roomId})`);

        if (socket.roomId && socket.role) {
            // Give them 15 seconds to reconnect (e.g. they are navigating from WaitingScreen to GameWrapper)
            const graceTimerKey = `${socket.gameId}-${socket.role}`;

            const timer = setTimeout(() => {
                console.log(`â˜ ï¸ Grace period expired for ${graceTimerKey}. Broadcasting disconnect.`);
                socket.to(socket.roomId).emit('opponent-disconnected', { role: socket.role });
                disconnectTimers.delete(graceTimerKey);
            }, 10000); // 10 seconds grace period

            disconnectTimers.set(graceTimerKey, timer);
        }
        // Don't clean up the game completely on disconnect â€” Game timeout cleans up after GAME_DURATION_MS
    });
});

// â”€â”€â”€ Market API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const MARKET_FILE = path.join(__dirname, 'market.json');
if (!fs.existsSync(MARKET_FILE)) fs.writeFileSync(MARKET_FILE, '[]');

app.get('/market', (_req, res) => {
    try { res.json(JSON.parse(fs.readFileSync(MARKET_FILE, 'utf8'))); }
    catch { res.status(500).json({ error: 'Failed to read market' }); }
});

app.post('/market', (req, res) => {
    const { cardId, price } = req.body;
    if (!cardId || price === undefined)
        return res.status(400).json({ error: 'Missing cardId or price' });
    try {
        const listings = JSON.parse(fs.readFileSync(MARKET_FILE, 'utf8'));
        const idx = listings.findIndex(l => l.cardId === cardId);
        if (idx !== -1) listings[idx].price = price;
        else listings.push({ cardId, price });
        fs.writeFileSync(MARKET_FILE, JSON.stringify(listings, null, 2));
        res.json({ success: true, listings });
    } catch { res.status(500).json({ error: 'Failed to update market' }); }
});

const PORT = process.env.PORT || 3000;
server.listen(PORT, () => console.log(`ðŸš€ Server running on port ${PORT}`));
